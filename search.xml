<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unity之VideoPlayer播放透明视频</title>
    <url>/Unity%E4%B9%8BVideoPlayer%E6%92%AD%E6%94%BE%E9%80%8F%E6%98%8E%E8%A7%86%E9%A2%91.html</url>
    <content><![CDATA[<html><head></head><body><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>  由于unity对视频格式的支持有限，因此如果想使用videoplayer播放透明视频需要对视频进行特殊处理；在unity中原生支持vp8编码的webm带透明通道的视频，所以我们需要将视频转成此格式；可以使用格式工厂将带透明通道的mov视频转换为webm格式的视频，然后在unity中使用。不过本文主要介绍另一种方式，使用ffmpeg将序列帧合成为带透明通道的视频。因此需要如下工具：<br>  <a href="http://ffmpeg.org/download.html#releases" target="_blank" rel="noopener">ffmpeg3.4.2</a><br>  <a href="https://pan.baidu.com/s/16qbYHGBjYAAEnxNrPftioA" target="_blank" rel="noopener">ReNamer</a>图片批量重命名，提取码：k0sd  </p>
<h3 id="图片重命名"><a href="#图片重命名" class="headerlink" title="图片重命名"></a>图片重命名</h3><p>  打开ReNamer软件，将所有图片拖拽到软件下方提示的额空白处，然后添加一个名称移除规则和一个名称序列化规则，完成图片的重命名，如下图所示：  </p>
<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/ReNamer.png">
</div>  

<h3 id="视频合成"><a href="#视频合成" class="headerlink" title="视频合成"></a>视频合成</h3><p>  下载ffmpeg，进入到”…/bin/“目录下，然后按下键盘下的“shift”+“鼠标右键”，打开Powershell命令行窗口，输入类似如下命令：  </p>
<p>  ./ffmpeg -y -r 25 -i 01/%3d.png -c:v libvpx -auto-alt-ref 0 -minrate 8500k -maxrate 8500k -b:v 8500k -quality best 1.webm<br>  说明：<br>  -r 表示视频帧率 -i 表示输入源 -c:v libvpx 表示视频编码格式，这里指明使用vp8编码格式（如果缺少此项，则默认使用vp9）<br>  下面两张图一个指定了编码格式，一个使用默认编码格式：  </p>
<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/vp8.png">
</div>  

<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/vp9.png">
</div>  

<p>  <a href="http://ffmpeg.org/ffmpeg-all.html" target="_blank" rel="noopener">FFmpeg说明文档</a></p>
<h3 id="Unity操作"><a href="#Unity操作" class="headerlink" title="Unity操作"></a>Unity操作</h3><p>  在unity中田间一个一个游戏GameObject，重命名为VideoPlayer，然后添加一个”VideoPlayer”组件，将视频拖拽到video clip上即可。Camera设置如下：  </p>
<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/Camera.png">
</div>   

<p>  最终效果如下:  </p>


<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=753099945&bvid=BV18k4y1k7FK&cid=185964691&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">
    </iframe>
</div>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  本次分享就到此结束。不过有时在实际的项目上我们会遇到需要播放大分辨的带透明通道的视频，此时还使用videoplayer播放，会发现合成的webm视频会模糊。有时可能还会有点卡顿。那么怎么解决呢？下一篇介绍另一种在unity播放透明视频的方法。</p>
<blockquote>
<p>上述介绍的软件如有收费，请大家支持正版<br>本文如有侵权，请联系删除</p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>Unity</category>
        <category>透明视频</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>透明视频</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯AI滤镜之Unity实现</title>
    <url>/%E8%85%BE%E8%AE%AFAI%E6%BB%A4%E9%95%9C%E4%B9%8BUnity%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<html><head></head><body><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>  因为我们要调用的是腾讯的远程API滤镜接口，因此要先注册账号（<a href="https://ai.qq.com" target="_blank" rel="noopener">注册地址</a>）,然后创建应用程序,进入控制台，点击“创建应用”即可完成创建。再查看应用信息，拷贝app_id和app_key,后面要用到。如下图所示：</p>
<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/chuangjian.png">
</div>

<p>这里也给出腾讯AI滤镜的开发文档地址(<a href="https://ai.qq.com/doc/ptuimgfilter.shtml" target="_blank" rel="noopener">开发文档</a>)，大家可以先自己了解一下，然后再往下看。</p>
<h3 id="核心代码讲解"><a href="#核心代码讲解" class="headerlink" title="核心代码讲解"></a>核心代码讲解</h3><p>  总共有天天P图和AI Lab两个滤镜API接口，不过参数基本相同，都是htpp post请求。本文是基于Unity2018.3.0进行开发，将使用UnityWebRequest进行post请求。API 具体的请求参数如下：</p>
<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/ptu.png">
</div>
  对于天天P图的API接口，总共有6个参数，app_id大家可以在上面创建的应用信息中找到，如下图：
<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/appinfo.png">
</div>
filter对应的是滤镜的效果id，天天P图有32种效果，为1-32；AI Lab有65种效果为1-65；接下来主要重点讲解一下其他三个个参数。
  首先是time_stamp，int类型，根据字段描述，可以知道是请求时间戳，以秒为单位，因此只要算出当前时间距1970.01.01：00：00：00的秒数就好，具体代码如下： 

<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">GetUnixTimestamp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//获取时间</span></span><br><span class="line">    TimeSpan timeSpan = DateTime.UtcNow - <span class="keyword">new</span> DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//将时间转换为以秒为单位，因此是64位的整型值</span></span><br><span class="line">    <span class="keyword">return</span> Convert.ToInt64(timeSpan.TotalSeconds).ToString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  然后是image参数，string类型，要求是base64编码数据(这是什么鬼)。刚看到，我也是一头雾水，通过查阅资料发现用C#实现就是先把图片转换为byte数组，然后再转换为base64字符串即可。具体代码如下：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">Bytes2Base64</span>(<span class="params"><span class="keyword">byte</span>[] bytes</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">string</span> base64 = Convert.ToBase64String(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mod = base64.Length % <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(mod > <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        base64 += <span class="keyword">new</span> <span class="keyword">string</span>(<span class="string">'='</span>, <span class="number">4</span> - mod);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> base64;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  不过有个坑就是，通过在线工具转换的base64字符串长度是4的整数倍，不足的用”=”补足了。因此上面的代码进行了4的倍数判断并自动补足。<br>  最后一个参数是sign，授权密钥，比较头疼，不过看过描述之后，觉得也还好。授权描述如下：</p>
<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/sign.png">
</div>
  从上面的描述，我们可以知道主要就是对请求参数按键值对中key值进行升序排列，然后并对value进行URL编码，并且URL编码采用大写字母；接着再将app_key放到字符串的最后；最后对得到的字符串进行MD5加密运算，并把加密字符串全部转换为大写字母。
  不过问题又来了，什么是URL编码？查阅资料，最后发现Unity中实现该算法，调用UnityWebRequest.EscapeURL(string)即可，但对得到的字符串要转换为大写字母。具体实现代码如下：

<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">ConvertURLEncode</span>(<span class="params"><span class="keyword">string</span> str, <span class="keyword">bool</span> isImage=<span class="literal">false</span></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">string</span> urlCode = UnityWebRequest.EscapeURL(str);</span><br><span class="line">    <span class="keyword">if</span> (isImage)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">string</span> str1 = UnityWebRequest.EscapeURL(<span class="string">"+"</span>);</span><br><span class="line">        <span class="keyword">string</span> str2 = UnityWebRequest.EscapeURL(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">string</span> str3 = UnityWebRequest.EscapeURL(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">        urlCode = urlCode.Replace(str1, str1.ToUpper());</span><br><span class="line">        urlCode = urlCode.Replace(str2, str2.ToUpper());</span><br><span class="line">        urlCode = urlCode.Replace(str3, str3.ToUpper());</span><br><span class="line">        <span class="keyword">return</span> urlCode;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> urlCode;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  对于上面的代码，大家会发现为什么对于图片的base64字符没有直接进行URL编码。这是因为URL编码只对部分字符进行编码，对数字和英文字母不进行编码(具体请看这里<a href="https://tools.ietf.org/html/rfc1738" target="_blank" rel="noopener">URL编码</a>)。而且如果我们对整个base64字符串进行URL编码，会消耗相当长的一段时间。因此我采用了如上的代码实现URL编码。<br>  URL编码我们已经会了，接下来就是对得到的字符串进行MD5运算，得到sign授权字符串。而C#刚好实现了MD5加密算法，具体代码如下：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">GetMD5Str</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = md5.ComputeHash(Encoding.UTF8.GetBytes(str));</span><br><span class="line">    <span class="comment">//转换为大写字母字符串</span></span><br><span class="line">    <span class="keyword">return</span> BitConverter.ToString(bytes).ToUpper().Replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  所有的参数我们都已经准备好了，那就可以进行Http post请求了，不过请求成供返回什么样的结果呢？具体可以看文档的描述，如下图所示：</p>
<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/result.png">
</div>
可以看到，返回的图片任然是以base64字符串的形式，因此我们要自己将base64字符串转换为图片，这个实现我就留给大家自己做了。不过有人该问了，这么多数据项，我要怎么拿到呀？其实返回的结果是json字符串给我们的，我们只要把json字符串利用Unity中的JsonUtility转换为对应参数的对象就可以了。我们可以将返回的结果定义为如下的数据结构：

<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Data</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> image;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageData</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> msg;</span><br><span class="line">    <span class="keyword">public</span> Data data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  最后一点就是对于AI Lab的API接口参数对了一个session_id参数，对于的是string类型，作用是请求id，只要保证每次请求值与之前不一样即可。下面是post请求表单和sign计算代码：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> WWWForm <span class="title">GetPostForm</span>(<span class="params"><span class="keyword">byte</span>[] imgBytes, FilterType filterType, <span class="keyword">int</span> filterId</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//将图片转换为Base64字符串</span></span><br><span class="line">    <span class="keyword">string</span> imgStr = Bytes2Base64(imgBytes);<span class="comment">//图片转为JPG格式的字符串，减小图片大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取时间戳</span></span><br><span class="line">    <span class="keyword">string</span> timeStamp = GetUnixTimestamp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请求字段</span></span><br><span class="line">    WWWForm form = <span class="keyword">new</span> WWWForm();</span><br><span class="line">    form.AddField(<span class="string">"app_id"</span>, <span class="keyword">int</span>.Parse(app_id));</span><br><span class="line">    form.AddField(<span class="string">"filter"</span>, filterId);</span><br><span class="line">    form.AddField(<span class="string">"image"</span>, imgStr);</span><br><span class="line">    form.AddField(<span class="string">"time_stamp"</span>, <span class="keyword">int</span>.Parse(timeStamp));</span><br><span class="line">    form.AddField(<span class="string">"nonce_str"</span>, timeStamp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取加密原字符串,对<key,value>按key升序排列</span></span><br><span class="line">    <span class="keyword">string</span> originalStr = <span class="string">"app_id="</span> + app_id +</span><br><span class="line">                        <span class="string">"&filter="</span> + filterId +</span><br><span class="line">                        <span class="string">"&image="</span> + ConvertURLEncode(imgStr, <span class="literal">true</span>) +</span><br><span class="line">                        <span class="string">"&nonce_str="</span> + timeStamp;</span><br><span class="line">    <span class="keyword">if</span> (filterType == FilterType.TTPTUFilter)</span><br><span class="line">    {</span><br><span class="line">        originalStr += <span class="string">"&time_stamp="</span> + timeStamp +</span><br><span class="line">                        <span class="string">"&app_key="</span> + app_key;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        originalStr += <span class="string">"&session_id="</span> + timeStamp +</span><br><span class="line">                        <span class="string">"&time_stamp="</span> + timeStamp +</span><br><span class="line">                        <span class="string">"&app_key="</span> + app_key;</span><br><span class="line">        form.AddField(<span class="string">"session_id"</span>, timeStamp);</span><br><span class="line">    }</span><br><span class="line">    form.AddField(<span class="string">"sign"</span>, GetMD5Str(originalStr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> form;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/ptufilter.png">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/labfilter.png">
</div>
  总算把这篇文章给写完写出来了，本来准备上周日就写的，一直拖到现在......后面会专注于新媒体互动开发的相关分享，不过只做应用方面的分享，不过讲底层的东西，大家可以自己去深挖研究。还有源工程就不放出来了,至于原因，就不说了，github速度......我已经不可以说什么了，不过这个速度慢的原因太多！！！

<blockquote>
<p>如有侵权，请联系删除！</p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>滤镜</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>滤镜</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式与游戏完美开发学习--状态模式(应用篇)</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-%E5%BA%94%E7%94%A8%E7%AF%87.html</url>
    <content><![CDATA[<html><head></head><body><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  上一个章节，我们已经了解了什么是状态模式，并设计实现了状态模式。本节我们主要来完成状态模式的实际应用。<br>  我们知道，基于Unity3D开发的游戏都只会再一个场景中运行，因此我们可以把每一个场景都当作一个状态类，并维护这个类。这样场景之间的跳转就可以看作是状态之间的跳转；而且同一时间只会有一个状态存在，也符合游戏执行时只有一个场景存在的实际情况。</p>
<h3 id="场景状态类SceneState的设计"><a href="#场景状态类SceneState的设计" class="headerlink" title="场景状态类SceneState的设计"></a>场景状态类SceneState的设计</h3><p>对于游戏大致可分为开始场景、主画面场景和打斗场景，因此可分别对于三个不同的状态。让三个场景类都继承ISceneState，然后再设计一个拥有者SceneStateController,而我们此次主要基于Unity3D来学习设计模式，因此我们还需要一个GameLoop类，让其拥有SceneStateController，以便完成与Unity3D的互动对接，结构如下图所示：</p>
<div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/SceneState.png">
</div>

<h4 id="说明如下："><a href="#说明如下：" class="headerlink" title="说明如下："></a>说明如下：</h4><blockquote>
<p>ISceneSate：场景类的接口，主要用于规范场景状态的行为；<br>StartState、MainMenuState、BattleState：分别对应开始场景、主画面场景和打斗场景；<br>SceneStateController：场景状态的拥有者，保持当前游戏状态，并控制场景状态的转变，而且负责与GameLoop互动操作；<br>GameLoop：游戏的主循环，负责与Unity3D互动，并且可以初始化游戏和定期更新游戏。</p>
</blockquote>
<h3 id="场景状态模式的实现"><a href="#场景状态模式的实现" class="headerlink" title="场景状态模式的实现"></a>场景状态模式的实现</h3><h4 id="ISceneState接口类实现"><a href="#ISceneState接口类实现" class="headerlink" title="ISceneState接口类实现"></a>ISceneState接口类实现</h4><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ISceneState</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 状态名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> m_StateName = <span class="string">"ISceneState"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> StateName</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> m_StateName;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        {</span><br><span class="line">            m_StateName = <span class="keyword">value</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态控制者</span></span><br><span class="line">    <span class="keyword">protected</span> SceneStateController m_Controller = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ISceneState</span>(<span class="params">SceneStateController controller</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        m_Controller = controller;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态开始，可初始化一些数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StateBegin</span>(<span class="params"></span>)</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态更新，可以做游戏定时更新输入等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StateUpdate</span>(<span class="params"></span>)</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态结束，可做资源释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StateEnd</span>(<span class="params"></span>)</span> { }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  StateBegin、StateUpdate和StateEnd三个方法分别完成每个场景状态的初始化、更新和结束场景状态时一些释放操作。</p>
<h4 id="开始状态类StartState的实现"><a href="#开始状态类StartState的实现" class="headerlink" title="开始状态类StartState的实现"></a>开始状态类StartState的实现</h4><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StartState</span> : <span class="title">ISceneState</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StartState</span>(<span class="params">SceneStateController controller</span>) : <span class="title">base</span>(<span class="params">controller</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        StateName = <span class="string">"StartState"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">StateBegin</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//可以在此进行游戏数据加载和初始化等</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">StateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//更新状态</span></span><br><span class="line">        m_Controller.SetState(<span class="keyword">new</span> MainMenuState(m_Controller), <span class="string">"MainMenuScene"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  开始场景主要完成一些游戏数据的加载，因此可以放在StateBegin方法中执行，而在StateUpdate方法中数据加载完成之后来切换游戏的状态，进入MainMenuState主画面场景。</p>
<h4 id="主画面场景类MainMenuState的实现"><a href="#主画面场景类MainMenuState的实现" class="headerlink" title="主画面场景类MainMenuState的实现"></a>主画面场景类MainMenuState的实现</h4><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainMenuState</span> : <span class="title">ISceneState</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainMenuState</span>(<span class="params">SceneStateController controller</span>) : <span class="title">base</span>(<span class="params">controller</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        StateName = <span class="string">"MainMenuState"</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">StateBegin</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Button tempBtn = GameObject.Find(<span class="string">"StartGameBtn"</span>).GetComponent< Button >();</span><br><span class="line">        <span class="keyword">if</span> (tempBtn)</span><br><span class="line">            tempBtn.onClick.AddListener(() => OnStartGameBtnClick(tempBtn));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始游戏按键的响应事件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnStartGameBtnClick</span>(<span class="params">Button button</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        m_Controller.SetState(<span class="keyword">new</span> BattleState(m_Controller), <span class="string">"BattleScene"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  主画面场景主要用来展示玩家的UI一些操作，本次只是简单的应用案例，因此我们在此场景主要时一个“开始”按钮，用来切换进入打斗场景。因此在StateBegin方法中完成开始按钮的查找和点击事件的初始化，当玩家点击按钮时，状态就会被切换为打斗状态，从而进入打斗场景。</p>
<h4 id="打斗场景BattleState的实现"><a href="#打斗场景BattleState的实现" class="headerlink" title="打斗场景BattleState的实现"></a>打斗场景BattleState的实现</h4><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BattleState</span> : <span class="title">ISceneState</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BattleState</span>(<span class="params">SceneStateController controller</span>) : <span class="title">base</span>(<span class="params">controller</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        StateName = <span class="string">"BattleState"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">StateBegin</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//游戏初始化等</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">StateEnd</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//状态的释放或其他资源的释放</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">StateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        InputProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//游戏逻辑更新</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//游戏是否结束</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 游戏输入</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InputProcess</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//玩家输入程序判断代码......</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  在刚开始的StateBegin方法中完成游戏画面等一些的初始化，然后在StateUpdate方法中完成游戏的输入、游戏逻辑、游戏状态的一些更新，最后如果状态结束就在StateEnd方法中完成一些资源的释放等操作。</p>
<h4 id="状态拥有者SceneStateController的实现"><a href="#状态拥有者SceneStateController的实现" class="headerlink" title="状态拥有者SceneStateController的实现"></a>状态拥有者SceneStateController的实现</h4><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneStateController</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">private</span> ISceneState m_State = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态是不是刚启动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> m_bRunBegin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景加载的进度</span></span><br><span class="line">    <span class="keyword">private</span> AsyncOperation asyncOperation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SceneStateController</span>(<span class="params"></span>)</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态</span></span><br><span class="line">    <span class="comment">// <param name="state">具体状态的实例</param></span></span><br><span class="line">    <span class="comment">// <param name="loadSceneName">场景名称</param></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetState</span>(<span class="params">ISceneState state,<span class="keyword">string</span> loadSceneName</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        m_bRunBegin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载场景</span></span><br><span class="line">        LoadScene(loadSceneName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放前一个状态</span></span><br><span class="line">        <span class="keyword">if</span> (m_State != <span class="literal">null</span>)</span><br><span class="line">            m_State.StateEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新状态</span></span><br><span class="line">        m_State = state;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 载入场景</span></span><br><span class="line">    <span class="comment">// <param name="sceneName">场景名称</param></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="keyword">string</span> sceneName</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(sceneName))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//异步加载场景</span></span><br><span class="line">        asyncOperation = SceneManager.LoadSceneAsync(sceneName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//Debug.Log(asyncOperation.progress);</span></span><br><span class="line">        <span class="comment">//场景是否加载完成</span></span><br><span class="line">        <span class="keyword">if</span> (asyncOperation != <span class="literal">null</span> && !asyncOperation.isDone)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知新的State开始</span></span><br><span class="line">        <span class="keyword">if</span>(m_State != <span class="literal">null</span> && m_bRunBegin == <span class="literal">false</span>)</span><br><span class="line">        {</span><br><span class="line">            m_bRunBegin = <span class="literal">true</span>;</span><br><span class="line">            m_State.StateBegin();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        <span class="keyword">if</span> (m_State != <span class="literal">null</span>)</span><br><span class="line">            m_State.StateUpdate();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  SceneStateController拥有一个IScneState字段，用来存储当前的游戏状态；SetState实现场景之间的相互转换，首先加载新场景，然后释放前一个场景并把当前场景设置为新的场景，由于加载场景使用了异步加载，因此在StateUpdate方法中先判断场景是否加载完毕，如果加载完毕则初始化新的场景并更新场景。</p>
<h4 id="游戏主循环GameLoop的实现"><a href="#游戏主循环GameLoop的实现" class="headerlink" title="游戏主循环GameLoop的实现"></a>游戏主循环GameLoop的实现</h4><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameLoop</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> SceneStateController sceneStateController = <span class="keyword">new</span> SceneStateController();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//切换场景时不销毁</span></span><br><span class="line">        DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//随机数种子</span></span><br><span class="line">        Random.InitState((<span class="keyword">int</span>)System.DateTime.Now.Ticks);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//设置起始场景</span></span><br><span class="line">        sceneStateController.SetState(<span class="keyword">new</span> StartState(sceneStateController), <span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        sceneStateController.StateUpdate();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  GameLoop中定义并初始化SceneStateController对象，在Start方法中初始化游戏场景状态，在Update方法中定时更新游戏状态。</p>
<p>  游戏结果在此就不放出了，有兴趣的可自行实现并体验，下面会给出具体的项目工程地址。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  在此状态模式的应用也就讲完了，但为什么我们要使用状态模式呢？<br>  首先，状态模式可以降低维护的难度：当有新的状态增加时，我们只要实现具体的状态，并完成状态的调用就好；也可以减少switch的使用。<br>  其次，状态执行环境单一化：因为每一个场景状态类已经完成了对一个状态的操作相关工作，因此可以清晰了解一个状态执行所需要的资源。<br>  最后我们再回到设计模式的最初目的，就是减少代码的重写，提高复用；因此使用状态模式可以在项目之间共享场景。<br>  那么状态模式还有哪些应用场景？动画有限状态机、NPC角色AI和服务器连接状态等。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><<设计模式与游戏完美开发>></p>
<hr>
<blockquote>
<p>项目工程地址：<a href="https://github.com/FredLyu/DesignPatternsLearn.git" target="_blank" rel="noopener">基于Unity的状态模式实现</a><br>如有侵权，请联系删除</p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>设计模式</category>
        <category>状态模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式与游戏完美开发学习--状态模式(概念篇)</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<html><head></head><body><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  既然是要学习设计模式，肯定得知道啥是设计模式，又有啥用？设计模式是啥？笔者我也不是特别，只听同道中人天天说。笔者自己的理解就是为了解决某一个问题(软件问题)而归纳总结出来的一套解决方案(软件模式)，而这套方案对以后出现的同样或类似接近的问题同样适用。个人觉得只要理解就好。哈哈哈！！！咱们进入今天的正题：设计模式之状态模式。</p>
<h3 id="状态模式的概念"><a href="#状态模式的概念" class="headerlink" title="状态模式的概念"></a>状态模式的概念</h3><p>  又要解释概念，好烦哦！GoF定义：让一个对象的行为随着内部状态的改变而改变，而该对象就像换了一个类一样（怎么觉得好像C++的多态）。个人理解就是一个对象对不同的状态做出不同的行为。还请指教！！！</p>
<h3 id="状态模式的说明"><a href="#状态模式的说明" class="headerlink" title="状态模式的说明"></a>状态模式的说明</h3><p>  既然已经知道了什么是状态模式，那怎么去实现呢？在实现之前，我们来先了解一下状态模式的结构。既然是状态模式，那肯定要有一个描述状态的类(State)，而根据定义”…随着内部状态的改变…”，那肯定不止一个状态，因此我们需要将State类作为基类去具体定义不同具体的状态类(ConcreteState),再看定义”让一个对象…”,因此我们还需要一个状态拥有者的类(Context)，去对不同的状态做出不同的行为。具体结构图如下：</p>
<div align="center">  
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/StateClassDiagram.png">
</div>

<h4 id="说明如下："><a href="#说明如下：" class="headerlink" title="说明如下："></a>说明如下：</h4><blockquote>
<p>Context: 状态拥有者，拥有状态属性，主要完成让外界得知状态的改变或者操作状态改变。<br>State: 状态的基类，指定状态的接口，负责规范状态拥有者要表现的行为。<br>ConcreteState: 具体的状态类，拥有特定状态下的行为，是状态的细化。</p>
</blockquote>
<h3 id="状态模式的实现"><a href="#状态模式的实现" class="headerlink" title="状态模式的实现"></a>状态模式的实现</h3><p>  根据以上对状态模式的分析，下面我们来做类的设计实现，首先是State基类：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 状态接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">State</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">protected</span> Context m_Context = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">State</span>(<span class="params">Context theContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        m_Context = theContext;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  声明一个Context对象，并作为State生成对象时传入的参数，以便State拥有Context,可以后续操作Context对象。定义抽象方法Handle，便于子类呈现不同的行为。  </p>
<p>  再定义一个Context类：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 状态拥有者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> State m_State = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        m_State.Handle(<span class="keyword">value</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetState</span>(<span class="params">State theState</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Debug.Log(<span class="string">"Context.SetState : "</span> + theState);</span><br><span class="line">        m_State = theState;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  Context类拥有State属性，可以通过Request来呈现当前状态的行为，通过SetState方法设置当前状态。</p>
<p>  最后定义三个具体的状态：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteStateA</span> : <span class="title">State</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteStateA</span>(<span class="params">Context theContext</span>) : <span class="title">base</span>(<span class="params">theContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Debug.Log(<span class="string">"ConcreteStateA.Handle"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">value</span> > <span class="number">10</span>)</span><br><span class="line">        {</span><br><span class="line">            m_Context.SetState(<span class="keyword">new</span> ConcreteStateB(m_Context));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteStateB</span> : <span class="title">State</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteStateB</span>(<span class="params">Context theContext</span>) : <span class="title">base</span>(<span class="params">theContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Debug.Log(<span class="string">"ConcreteStateB.Handle"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> > <span class="number">20</span>)</span><br><span class="line">        {</span><br><span class="line">            m_Context.SetState(<span class="keyword">new</span> ConcreteStateC(m_Context));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcreteStateC</span> : <span class="title">State</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteStateC</span>(<span class="params">Context theContext</span>) : <span class="title">base</span>(<span class="params">theContext</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Debug.Log(<span class="string">"ConcreteStateC.Handle"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> > <span class="number">30</span>)</span><br><span class="line">        {</span><br><span class="line">            m_Context.SetState(<span class="keyword">new</span> ConcreteStateA(m_Context));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  三个子类分别实现了Handle方法来表现各自的行为。然后根据判定条件来通知Context(状态拥有者)状态发生改变。</p>
<p>  下面我们来编写测试代码：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestState</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.SetState(<span class="keyword">new</span> ConcreteStateA(context));</span><br><span class="line">        context.Request(<span class="number">5</span>);</span><br><span class="line">        context.Request(<span class="number">15</span>);</span><br><span class="line">        context.Request(<span class="number">25</span>);</span><br><span class="line">        context.Request(<span class="number">35</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  首先生成一个Context对象，然后设置状态为ConcreteStateA，再调用Request来变现不同行为并转换状态。执行结果如下：  </p>
<div align="center">
<img src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/StateTestResult.png">
</div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  状态设计模式就介绍到这为止，下一篇我们做一个简单的应用案例。笔者也是刚刚学习，如有解释不到的地方还请见谅。对于编程这块，个人认为还是要多加应用才能理解更深。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><<设计模式与游戏完美开发>></p>
<blockquote>
<p>如有侵权，请联系删除！</p>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>设计模式</category>
        <category>状态模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Unity的A星算法实现</title>
    <url>/%E5%9F%BA%E4%BA%8EUnity%E7%9A%84A%E6%98%9F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-md.html</url>
    <content><![CDATA[<html><head></head><body><p>  本篇实现的A星算法是基于贪婪优先算法实现的，由于贪婪优先算法得到的是次优路径，因此我们增加一个当前节点到起始节点的一个路径开销分量来提升路径的质量，筛选最优路径。具体实现如下：</p>
<h3 id="节点类的编写"><a href="#节点类的编写" class="headerlink" title="节点类的编写"></a>节点类的编写</h3><p>  节点主要用来存储当前节点在地图中的位置信息，如：行号，列号、父节点、到起始节点的路径开销量g，到目标节点的路径开销量h，总的开销量；并包含计算g和h的方法；具体实现代码如下：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 节点类</span></span><br><span class="line">public class ANode : System.IComparable</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="comment">// 列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Col { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    <span class="keyword">public</span> ANode parent = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 相邻节点</span></span><br><span class="line">    <span class="keyword">public</span> List<ANode> adjacent = <span class="keyword">new</span> List<ANode>();</span><br><span class="line">    <span class="comment">// 曼哈顿距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">H</span>(<span class="params">ANode endNode</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        h = Mathf.Abs(endNode.Row - Row) + Mathf.Abs(endNode.Col - Col);</span><br><span class="line"></span><br><span class="line">        f = g + h;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        parent = <span class="literal">null</span>;</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        g = <span class="number">0</span>;</span><br><span class="line">        f = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="keyword">object</span> obj</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        ANode node = obj <span class="keyword">as</span> ANode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f - node.f < <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f - node.f == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="地图存储"><a href="#地图存储" class="headerlink" title="地图存储"></a>地图存储</h3><p>  地图存储与贪婪算法中的思路一样，代码逻辑一样，只是把节点变量换一下即可，这里不在描述，代码大家自行实现。</p>
<h3 id="寻路算法实现"><a href="#寻路算法实现" class="headerlink" title="寻路算法实现"></a>寻路算法实现</h3><p>  寻路算法与贪婪优先算法的实现相比只是增加了一个与起点的开销分量计算，然后根据f值来判断最优路径，具体实现代码如下：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AStarAlgorithm</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> ANode startNode;</span><br><span class="line">    <span class="keyword">private</span> ANode destNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List<ANode> openSet = <span class="keyword">new</span> List<ANode>();</span><br><span class="line">    <span class="keyword">private</span> List<ANode> closedSet = <span class="keyword">new</span> List<ANode>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AMap map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化地图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AStarAlgorithm</span>(<span class="params">AMap map</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找开放式集合中H值最小的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ANode <span class="title">FindLowest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        openSet.Sort();</span><br><span class="line">        <span class="keyword">return</span> openSet[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点的相邻节点添加到开放集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddAdjacent</span>(<span class="params">ANode node</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < node.adjacent.Count; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (closedSet.Contains(node.adjacent[i]))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> newG = node.g + Mathf.Abs(node.Row - node.adjacent[i].Row) + Mathf.Abs(node.Col - node.adjacent[i].Col);</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(newG < node.adjacent[i].g || !openSet.Contains(node.adjacent[i]))</span><br><span class="line">            {</span><br><span class="line">                node.adjacent[i].parent = node;</span><br><span class="line">                node.adjacent[i].g = newG;</span><br><span class="line">                node.adjacent[i].H(destNode);</span><br><span class="line">                <span class="keyword">if</span> (!openSet.Contains(node.adjacent[i]))</span><br><span class="line">                    openSet.Add(node.adjacent[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新地图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateMap</span>(<span class="params">AMap map</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params">ANode startNode, ANode endNode</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        openSet.Clear();</span><br><span class="line">        closedSet.Clear();</span><br><span class="line"></span><br><span class="line">        openSet.Add(startNode);</span><br><span class="line">        destNode = endNode;</span><br><span class="line">        <span class="keyword">this</span>.startNode = startNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < map.aNodes.Length; i++)</span><br><span class="line">        {</span><br><span class="line">            map.aNodes[i].Clear();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stack<ANode> <span class="title">Find</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Stack<ANode> path = <span class="keyword">new</span> Stack<ANode>();</span><br><span class="line"></span><br><span class="line">        ANode currNode = openSet[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (currNode != destNode)</span><br><span class="line">        {              </span><br><span class="line">            <span class="keyword">if</span> (openSet.Count == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            currNode = FindLowest();</span><br><span class="line">            openSet.Remove(currNode);</span><br><span class="line">            closedSet.Add(currNode);</span><br><span class="line"></span><br><span class="line">            AddAdjacent(currNode);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currNode == destNode)</span><br><span class="line">        {</span><br><span class="line">            ANode node = destNode;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                path.Push(node);</span><br><span class="line">                node = node.parent;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>对于节点类的优化可以继承贪婪优先算法的节点类，这样便于维护修改。</p>
</blockquote>
<h3 id="Unity实现效果如下"><a href="#Unity实现效果如下" class="headerlink" title="Unity实现效果如下"></a>Unity实现效果如下</h3><div align="center">
<img data-src="https://raw.githubusercontent.com/FredLyu/FigureBed-Hector/master/BlogFigure/A星算法效果.png">
</div>


<blockquote>
<p>完整工程仓库地址：<a href="https://github.com/FredLyu/GameProgramingAlgorithmsAndTechniques.git" target="_blank" rel="noopener">A星算法</a> </p>
</blockquote>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《游戏编程算法与技巧》</p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>A星算法</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>寻路</tag>
        <tag>A星算法</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏寻路--基于Unity的贪婪最佳优先算法实现</title>
    <url>/%E8%B4%AA%E5%A9%AA%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<html><head></head><body><p>  贪婪最佳优先算法是一种没有做任何长期计划就马上选择最佳答案的算法。因此贪婪优先算法得到的寻路路径是一种次优路径。算法流程如下：<br><img data-src="https://i.imgur.com/rZVHfZT.png" alt="流程图"><br>  下面来根据流程图完成代码的编写。<a id="more"></a> </p>
<h3 id="节点类的编写"><a href="#节点类的编写" class="headerlink" title="节点类的编写"></a>节点类的编写</h3><p>  节点主要用来存放当前地图中位置信息，包括当前位置的行号、列号、父节点、邻居节点集合和当前节点到目标节点的距离，代码如下:</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//行号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row{ <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="comment">//列号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Col{ <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="comment">//邻居节点的集合</span></span><br><span class="line">    <span class="keyword">public</span> List<Node> adjacent=<span class="keyword">new</span> List<Node>();</span><br><span class="line">    <span class="comment">//到目标节点的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> h = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        parent=<span class="literal">null</span>;</span><br><span class="line">        h=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  其中到目标节点的距离为曼哈顿距离，即当前节点到目标节点的向量的x、y的绝对值的和。</p>
<h3 id="地图的存储"><a href="#地图的存储" class="headerlink" title="地图的存储"></a>地图的存储</h3><p>  有了节点之后便可以构成一张二维地图，地图中有可行的节点和不可行的节点(障碍物),这里我们用0表示可通过，1表示不可通过。代码如下：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Map</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Rows;</span><br><span class="line">    <span class="comment">//列数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Cols;</span><br><span class="line">    <span class="comment">//地图中的节点，行优先排列</span></span><br><span class="line">    <span class="keyword">public</span> Node[] nodes;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Map</span>(<span class="params"><span class="keyword">int</span>[,] mapArray</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Rows = mapArray.GetLength(<span class="number">0</span>);</span><br><span class="line">        Cols = mapArray.GetLength(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//分配地图节点</span></span><br><span class="line">        nodes=<span class="keyword">new</span> Node[Rows * Cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < nodes.Length; i++)</span><br><span class="line">        {</span><br><span class="line">            Node node = <span class="keyword">new</span> Node();</span><br><span class="line">            node.Row = i / Cols;</span><br><span class="line">            node.Col = i % Cols;</span><br><span class="line">            </span><br><span class="line">            nodes[i] = node;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row , col;</span><br><span class="line">        <span class="comment">//分配邻居节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < nodes.Length; j++)</span><br><span class="line">        {</span><br><span class="line">            row = nodes[j].Row;</span><br><span class="line">            col = nodes[j].Col;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1表示有障碍物，不能通过</span></span><br><span class="line">            <span class="comment">//0表示无障碍物，可以通过</span></span><br><span class="line">            <span class="keyword">if</span>(mapArray[row,col] != <span class="number">1</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//相邻上方的一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (row > <span class="number">0</span> && mapArray[row - <span class="number">1</span>, col] != <span class="number">1</span>)</span><br><span class="line">                    nodes[j].adjacent.Add(nodes[(row - <span class="number">1</span>) * cols + col]);</span><br><span class="line">                <span class="comment">//相邻右边的一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (col + <span class="number">1</span> < cols && mapArray[row, col + <span class="number">1</span>] != <span class="number">1</span>)</span><br><span class="line">                    nodes[j].adjacent.Add(nodes[row * cols + col + <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//相邻下方的一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (row + <span class="number">1</span> < rows && mapArray[row + <span class="number">1</span>, col] != <span class="number">1</span>)</span><br><span class="line">                    nodes[j].adjacent.Add(nodes[(row + <span class="number">1</span>) * cols + col]);</span><br><span class="line">                <span class="comment">//相邻左边的一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (col > <span class="number">0</span> && mapArray[row, col - <span class="number">1</span>] != <span class="number">1</span>)</span><br><span class="line">                    nodes[j].adjacent.Add(nodes[row * cols + col - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  地图生成完之后，就可以根据起始点和目标点来寻找一条”最优”的到达路径了。</p>
<h3 id="寻路算法实现"><a href="#寻路算法实现" class="headerlink" title="寻路算法实现"></a>寻路算法实现</h3><p>  在有了地图信息之后，我们还不能立马去搜索地图寻找”最优”路径，因为我们还需要两个集合来存放地图搜索过程中以确定的节点和未确定但以估算h(x)值的节点，分别是封闭集合和开放集合。这样我们可以根据当前节点的邻居节点信息，算出所有邻居节点到目标点的曼哈顿距离h(x)，并将当前节点作为邻居节点的父节点。而在计算一个节点的h(x)之前，我们首先要判断此节点是否存在于封闭集合中，如果不存在则计算，否侧继续下一个节点的判断，并把此节点加入到开放集合中。<br>  在处理完邻居节点之后，此时我们还需要查看开放集合是否为空，如果为空则证明路径查找失败，退出路径查找。否则从开放集合中找出曼哈顿最小的节点加入到封闭集合从并从开放集合中一处，然后将此节点作为当前节点继续下一轮的查找，直至当前节点为目标节点。这样我们就可以得到一个链表，通过parent从终点指想起点，我们需要将其逆置得到我们想要的从起点到终点的路径。完整代码如下：  </p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreedBestPriorityAlgorithm</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//地图</span></span><br><span class="line">    <span class="keyword">private</span> Map map;</span><br><span class="line">    <span class="comment">//终点</span></span><br><span class="line">    <span class="keyword">private</span> Node destNode;</span><br><span class="line">    <span class="comment">//开放集合</span></span><br><span class="line">    <span class="keyword">private</span> List<Node> openSet = <span class="keyword">new</span> List<Node>();</span><br><span class="line">    <span class="comment">//封闭集合</span></span><br><span class="line">    <span class="keyword">private</span> List<Node> closedSet = <span class="keyword">new</span> List<Node>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化地图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreedyBestPriorityAlgorithm</span>(<span class="params">Map map</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">this</span>.map = map</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算曼哈顿距离</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">H</span>(<span class="params">Node node</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">return</span> Mathf.Abs(node.Row - destNode.Row) + Mathf.Abs(node.Col - destNode.Col);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找开放式集合中h(x)值最小的点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">FindLowestH</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Node node = openSet[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < opencSet.Count; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(openSet[i].h < node.h)</span><br><span class="line">            {</span><br><span class="line">                node = openSet[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算当前节点邻居节点的h(x)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddAdjacent</span>(<span class="params">Node node</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < node.adjacent.Count; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(closedSet.Contains(node.adjacent[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                node.adjacent[i].parent = node;</span><br><span class="line">                <span class="keyword">if</span>(!openSet.Contains(node.adjacent[i])</span><br><span class="line">                {</span><br><span class="line">                    node.adjacent[i].h = H(node.adjacent[i]);</span><br><span class="line">                    openSet.Add(node.adjacent[i]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新地图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UpdateMap</span>(<span class="params">Map map</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置起点、终点、清楚地图节点存放的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params">Node startNode, Node endNode</span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        openSet.Clear();</span><br><span class="line">        closedSet.Clear();</span><br><span class="line">        </span><br><span class="line">        closedSet.Add(startNode);</span><br><span class="line">        destNode = endNode;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < map.nodes.Length; i++)</span><br><span class="line">        {</span><br><span class="line">            map.nodes[i].Clear();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stack<Node> <span class="title">Find</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    {</span><br><span class="line">        Stack<Node> path = <span class="keyword">new</span> Stack<Node>();</span><br><span class="line">        Node currNode = closedSet[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(currNode != destNode)</span><br><span class="line">        {</span><br><span class="line">            AddAdjacent(currNode);</span><br><span class="line">            <span class="keyword">if</span>(openSet.Count == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            currNode = FindLowestH();</span><br><span class="line">            closedSet.Add(currNode);</span><br><span class="line">            openSet.Remove(currNode);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(currNode == destNode)</span><br><span class="line">        {</span><br><span class="line">            Node node = destNode;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                path.Push(node);</span><br><span class="line">                </span><br><span class="line">                node = node.parent;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  对于最后的路径使用栈逆置，如果不想使用也可以直接计算起点到终点的路径，这样可以减少一定的计算开销。对于此算法还可以进行如下优化：   </p>
<blockquote>
<p>对于从开放集合中查找最小h(x)值的节点，我们可以使用二叉树最为开放集合(左边是比根节点小的值，右边是比根节点大的值)，这样查找速度就是O(1)；</p>
</blockquote>
<h3 id="Unity实现效果"><a href="#Unity实现效果" class="headerlink" title="Unity实现效果"></a>Unity实现效果</h3><p><img data-src="https://i.imgur.com/oIzyIur.png" alt>    </p>
<blockquote>
<p>完整工程仓库地址：<a href="https://github.com/FredLyu/GameProgramingAlgorithmsAndTechniques.git" target="_blank" rel="noopener">贪婪最佳优先算法</a><br>CSDND地址：<a href="https://blog.csdn.net/puraples/article/details/88071496" target="_blank" rel="noopener">基于Unity的贪婪最佳优先算法</a></p>
</blockquote>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《游戏编程算法与技巧》<br><a href="http://forum.china.unity3d.com/thread-29592-1-1.html" target="_blank" rel="noopener">寻路算法-贪婪最佳优先算法</a></p>
</body></html>]]></content>
      <categories>
        <category>算法</category>
        <category>贪婪最佳优先算法</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>寻路</tag>
        <tag>贪婪最佳优先算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo的GitHub个人博客搭建</title>
    <url>/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84GitHub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-md.html</url>
    <content><![CDATA[<html><head></head><body><pre><code>凌晨两点半，记录一下搭建Github博客踩的坑吧！！！</code></pre><h2 id="1-权限不够"><a href="#1-权限不够" class="headerlink" title="1.权限不够"></a>1.权限不够</h2><p>在window下要以管理员的权限运行Git Bash。害得我浪费时间熬夜到现在，都是泪。<br>2.空格问题<br>–<br>记住编辑的.yml文件，每项后面都跟一个英文空格符，否则执行hexo命令会报错，如下：<br><strong>FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 12, column 9:<br>    timezone:</strong></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/38122668" target="_blank" rel="noopener">小白搭建Hexo+github博客（win 10）</a></p>
</body></html>]]></content>
      <categories>
        <category>hexo</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
